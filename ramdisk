#!/usr/bin/env bash

set -euo pipefail

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Script version
readonly VERSION="1.0.0"

# Function to print colored output
print_error() {
    echo -e "${RED}ERROR: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}SUCCESS: $1${NC}"
}

print_info() {
    echo -e "${BLUE}INFO: $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}WARNING: $1${NC}"
}

# Function to display usage information
show_usage() {
    cat <<EOF
ramdisk - RAM Disk Management Tool for macOS v${VERSION}

USAGE:
    ramdisk <command> [options]

COMMANDS:
    create <size_mb> <name> [--encrypted] [--no-index]
                               Create a new RAM disk
                               - size_mb: Size in megabytes (e.g., 100, 512, 1024)
                               - name: Volume name (e.g., RAMDisk, TempCache)
                               - --encrypted: Optional. Create encrypted APFS volume
                                 Generates a strong random password displayed once
                               - --no-index: Optional. Disable Spotlight, Time Machine,
                                 and other indexing services for better performance

    list                       List all RAM disks

    destroy <identifier>       Destroy/unmount a RAM disk
                               - identifier: Volume name or device path (e.g., RAMDisk or /dev/disk3)

    help                       Show this help message

    version                    Show version information

EXAMPLES:
    # Create a 512MB RAM disk named "TempCache"
    ramdisk create 512 TempCache

    # Create an encrypted 512MB RAM disk
    ramdisk create 512 SecureCache --encrypted

    # Create a RAM disk with indexing disabled (better performance)
    ramdisk create 512 FastCache --no-index

    # Create an encrypted RAM disk with no indexing
    ramdisk create 512 SecureFastCache --encrypted --no-index

    # List all RAM disks
    ramdisk list

    # Destroy RAM disk by name
    ramdisk destroy TempCache

    # Destroy RAM disk by device path
    ramdisk destroy /dev/disk3

NOTES:
    - RAM disks are mounted under /Volumes/<name>
    - All data on a RAM disk is lost when it's destroyed or the system reboots
    - Encrypted RAM disks use APFS encryption with auto-generated passwords
    - Save the password shown during creation - it cannot be recovered
    - --no-index disables Spotlight, Time Machine, and other indexing (may require sudo)
    - Requires sudo/root privileges for some operations

EOF
}

# Function to check if running on macOS
check_macos() {
    if [[ "$(uname)" != "Darwin" ]]; then
        print_error "This script only works on macOS"
        exit 1
    fi
}

# Function to validate size parameter
validate_size() {
    local size=$1

    if ! [[ "$size" =~ ^[0-9]+$ ]]; then
        print_error "Size must be a positive integer"
        return 1
    fi

    if (( size < 1 )); then
        print_error "Size must be at least 1 MB"
        return 1
    fi

    # Check available system RAM
    local total_ram_bytes
    total_ram_bytes=$(sysctl -n hw.memsize 2>/dev/null)

    if [[ -n "$total_ram_bytes" ]]; then
        local total_ram_mb=$((total_ram_bytes / 1024 / 1024))
        local available_ram_mb=$((total_ram_mb * 80 / 100))  # Use 80% as safe threshold

        if (( size > total_ram_mb )); then
            print_error "Requested size (${size}MB) exceeds total system RAM (${total_ram_mb}MB)"
            return 1
        fi

        if (( size > available_ram_mb )); then
            print_warning "Requested size (${size}MB) is more than 80% of total RAM (${total_ram_mb}MB)."
            print_warning "This may cause system instability or performance issues."
            read -p "Continue? (y/n) " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                print_info "Operation cancelled"
                exit 0
            fi
        fi
    fi

    if (( size > 32768 )); then
        print_warning "Creating very large RAM disk (${size}MB)."
        read -p "Continue? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Operation cancelled"
            exit 0
        fi
    fi

    return 0
}

# Function to generate a strong random password
generate_password() {
    # Generate a 24-character password with letters, numbers, and symbols
    # Using /dev/urandom for cryptographic randomness
    # Read enough random data first (96 bytes should be plenty), then filter to desired character set
    head -c 96 < /dev/urandom | LC_ALL=C tr -dc 'A-Za-z0-9!@#$%^&*()_+=' | head -c 24
}

# Function to validate volume name
validate_name() {
    local name=$1

    if [[ -z "$name" ]]; then
        print_error "Volume name cannot be empty"
        return 1
    fi

    # Check length limit (reasonable for display and filesystem)
    if [[ ${#name} -gt 64 ]]; then
        print_error "Volume name is too long (max 64 characters)"
        return 1
    fi

    # Use whitelist approach - only allow alphanumeric, spaces, hyphens, and underscores
    # This prevents shell injection and special character issues
    if [[ ! "$name" =~ ^[a-zA-Z0-9][a-zA-Z0-9\ _-]*$ ]]; then
        print_error "Volume name can only contain letters, numbers, spaces, hyphens, and underscores"
        print_error "Name must start with a letter or number"
        return 1
    fi

    # Check if volume already exists
    if [[ -d "/Volumes/$name" ]]; then
        print_error "Volume '/Volumes/$name' already exists"
        return 1
    fi

    return 0
}

# Function to disable indexing services on a volume
disable_indexing() {
    local volume_name=$1
    local mount_point="/Volumes/$volume_name"

    print_info "Disabling indexing services..."

    # Create .metadata_never_index file to prevent Spotlight indexing
    if touch "$mount_point/.metadata_never_index" 2>/dev/null; then
        print_info "✓ Spotlight indexing disabled (.metadata_never_index created)"
    else
        print_warning "Could not create .metadata_never_index file"
    fi

    # Disable Spotlight indexing using mdutil
    if mdutil -i off "$mount_point" >/dev/null 2>&1; then
        print_info "✓ Spotlight indexing disabled (mdutil)"
    else
        print_warning "Could not disable Spotlight via mdutil (may require sudo)"
    fi

    # Add Time Machine exclusion
    if tmutil addexclusion "$mount_point" 2>/dev/null; then
        print_info "✓ Time Machine backups disabled"
    else
        print_warning "Could not add Time Machine exclusion (may require sudo)"
    fi
}

# Function to create a RAM disk
create_ramdisk() {
    local size_mb=$1
    local volume_name=$2
    local encrypted=$3
    local no_index=$4

    # Validate inputs
    validate_size "$size_mb" || exit 1
    validate_name "$volume_name" || exit 1

    local encryption_msg=""
    if [[ "$encrypted" == "true" ]]; then
        encryption_msg=" (encrypted)"
    fi

    print_info "Creating ${size_mb}MB RAM disk${encryption_msg} with name '${volume_name}'..."

    # Create the RAM disk (size is in 512-byte sectors)
    local sectors=$((2 * 1024 * size_mb))
    local device

    if ! device=$(hdiutil attach -nomount "ram://${sectors}" 2>&1); then
        print_error "Failed to create RAM disk: $device"
        exit 1
    fi

    # Extract device name (e.g., /dev/disk3)
    device=$(echo "$device" | grep -o '/dev/disk[0-9]*' | head -1)

    if [[ -z "$device" ]]; then
        print_error "Failed to get device name"
        exit 1
    fi

    print_info "RAM disk device created: $device"

    # Format and mount the disk
    print_info "Formatting and mounting..."

    local password=""
    if [[ "$encrypted" == "true" ]]; then
        # Generate strong random password for encryption
        password=$(generate_password)

        # Step 1: Create APFS container (no encryption at container level)
        # createContainer returns a new disk identifier for the container
        # Use TERM=dumb to prevent ANSI color codes in output
        local container_output
        container_output=$(TERM=dumb diskutil apfs createContainer "$device" 2>&1) || {
            print_error "Failed to create APFS container"
            # Attempt to clean up
            hdiutil detach "$device" 2>/dev/null || true
            exit 1
        }

        # Extract the new container disk identifier (e.g., "Created new APFS Container disk11")
        local container_device
        container_device=$(echo "$container_output" | grep "Created new APFS Container" | grep -o 'disk[0-9]*' | head -1)

        if [[ -z "$container_device" ]]; then
            print_error "Failed to get container device identifier"
            hdiutil detach "$device" 2>/dev/null || true
            exit 1
        fi

        # Step 2: Add encrypted volume to the container
        # Capture output instead of redirecting to /dev/null to avoid breaking stdin pipe
        local add_volume_output
        if ! add_volume_output=$(echo "$password" | diskutil apfs addVolume "$container_device" APFS "$volume_name" -stdinpassphrase 2>&1); then
            print_error "Failed to add encrypted volume"
            # Attempt to clean up
            diskutil apfs deleteContainer "$container_device" 2>/dev/null || true
            hdiutil detach "$device" 2>/dev/null || true
            exit 1
        fi
    else
        # Create standard HFS+ volume
        if ! diskutil eraseVolume HFS+ "$volume_name" "$device" >/dev/null 2>&1; then
            print_error "Failed to format and mount RAM disk"
            # Attempt to clean up
            hdiutil detach "$device" 2>/dev/null || true
            exit 1
        fi
    fi

    # Disable indexing if requested
    if [[ "$no_index" == "true" ]]; then
        echo ""
        disable_indexing "$volume_name"
    fi

    print_success "RAM disk created successfully"
    echo ""
    echo "  Device:      $device"
    echo "  Volume Name: $volume_name"
    echo "  Size:        ${size_mb}MB"
    echo "  Mount Point: /Volumes/$volume_name"
    if [[ "$encrypted" == "true" ]]; then
        echo "  Encryption:  APFS Encrypted"
        echo ""
        print_warning "IMPORTANT: Save this password - it cannot be recovered!"
        echo ""
        echo -e "  ${YELLOW}Password: ${password}${NC}"
    fi
    if [[ "$no_index" == "true" ]]; then
        echo "  Indexing:    Disabled (Spotlight, Time Machine)"
    fi
    echo ""
    print_info "Access your RAM disk at: /Volumes/$volume_name"
}

# Function to list RAM disks
list_ramdisks() {
    print_info "Scanning for RAM disks..."
    echo ""

    local found=0
    local hdiutil_output

    # Get hdiutil info output (TERM=dumb prevents ANSI color codes)
    if ! hdiutil_output=$(TERM=dumb hdiutil info 2>/dev/null); then
        print_error "Failed to get disk image information"
        return 1
    fi

    # Parse hdiutil output to find RAM disks (those with image-path: ram://...)
    local current_image_path=""
    local current_device=""
    local current_mount=""

    while IFS= read -r line; do
        # Look for image-path lines
        if [[ "$line" =~ ^image-path[[:space:]]*:[[:space:]]*ram:// ]]; then
            current_image_path=$(echo "$line" | sed 's/^image-path[[:space:]]*:[[:space:]]*//')
        fi

        # Look for device lines (e.g., "/dev/disk10    /Volumes/TestRAM")
        if [[ -n "$current_image_path" ]] && [[ "$line" =~ ^/dev/disk[0-9]+ ]]; then
            current_device=$(echo "$line" | awk '{print $1}')
            current_mount=$(echo "$line" | cut -d$'\t' -f2- | xargs)

            # Get detailed disk info
            local disk_info
            if disk_info=$(diskutil info "$current_device" 2>/dev/null); then
                local volume_name=$(echo "$disk_info" | grep "Volume Name:" | sed 's/.*Volume Name:[[:space:]]*//')
                local size=$(echo "$disk_info" | grep "Disk Size:" | sed 's/.*Disk Size:[[:space:]]*//')
                local mount_point=$(echo "$disk_info" | grep "Mount Point:" | sed 's/.*Mount Point:[[:space:]]*//')

                found=1
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "  Device:      $current_device"
                [[ -n "$volume_name" ]] && echo "  Volume Name: $volume_name"
                [[ -n "$mount_point" ]] && echo "  Mount Point: $mount_point"
                [[ -n "$size" ]] && echo "  Size:        $size"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo ""
            fi
        fi

        # Reset when we hit a separator
        if [[ "$line" =~ ^=+$ ]]; then
            current_image_path=""
            current_device=""
            current_mount=""
        fi
    done <<< "$hdiutil_output"

    if [[ $found -eq 0 ]]; then
        print_info "No RAM disks found"
    fi
}

# Function to destroy a RAM disk
destroy_ramdisk() {
    local identifier=$1

    if [[ -z "$identifier" ]]; then
        print_error "No identifier provided"
        echo "Usage: ramdisk destroy <volume_name_or_device>"
        exit 1
    fi

    local device=""

    # Check if identifier is a device path
    if [[ "$identifier" =~ ^/dev/disk[0-9]+$ ]]; then
        device="$identifier"
    else
        # Try to find device by volume name
        local mount_point="/Volumes/$identifier"

        if [[ ! -d "$mount_point" ]]; then
            print_error "Volume '$identifier' not found at /Volumes/$identifier"
            exit 1
        fi

        # Get device from mount point
        device=$(diskutil info "$mount_point" 2>/dev/null | grep "Device Node:" | awk '{print $3}')

        if [[ -z "$device" ]]; then
            print_error "Could not determine device for volume '$identifier'"
            exit 1
        fi
    fi

    # Verify device exists
    if [[ ! -e "$device" ]]; then
        print_error "Device $device does not exist"
        exit 1
    fi

    # Verify we can get disk info for this device
    if ! diskutil info "$device" >/dev/null 2>&1; then
        print_error "Unable to get information for device $device"
        exit 1
    fi

    print_info "Verifying device: $device"

    # Verify it's actually a RAM disk before destroying
    # Use TERM=dumb to prevent ANSI color codes in output
    # Use grep -w for word boundary matching to prevent false matches (e.g., disk1 vs disk10)
    local hdiutil_output
    hdiutil_output=$(TERM=dumb hdiutil info 2>/dev/null)

    # Check if this device is associated with a ram:// image
    local is_ramdisk=0
    if echo "$hdiutil_output" | grep -A 20 "image-path.*:.*ram://" | grep -qw "$device"; then
        is_ramdisk=1
    fi

    if [[ $is_ramdisk -eq 0 ]]; then
        print_error "Device $device is not a RAM disk"
        print_error "Refusing to destroy non-RAM disk for safety"
        print_info "Use diskutil or hdiutil directly if you're certain"
        exit 1
    fi

    print_info "Unmounting and destroying RAM disk: $device"

    # Unmount and detach
    if ! hdiutil detach "$device" 2>/dev/null; then
        # Try force unmount if normal detach fails
        print_warning "Normal detach failed. The disk may be in use."
        print_warning "Force unmounting may cause data loss if files are being written."
        read -p "Attempt force unmount? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Operation cancelled"
            print_info "Tip: Close any applications using the RAM disk and try again"
            exit 1
        fi

        if ! diskutil unmountDisk force "$device" 2>/dev/null; then
            print_error "Failed to force unmount RAM disk"
            print_info "The disk may be in use by system processes"
            exit 1
        fi
        # Try detach again
        hdiutil detach "$device" 2>/dev/null || true
    fi

    print_success "RAM disk destroyed successfully"
}

# Main script logic
main() {
    check_macos

    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 0
    fi

    local command=$1
    shift

    case "$command" in
        create)
            if [[ $# -lt 2 ]] || [[ $# -gt 4 ]]; then
                print_error "Invalid arguments for 'create' command"
                echo "Usage: ramdisk create <size_mb> <name> [--encrypted] [--no-index]"
                exit 1
            fi

            local size_mb="$1"
            local volume_name="$2"
            local encrypted="false"
            local no_index="false"

            # Process optional flags
            shift 2  # Skip size and name arguments
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --encrypted)
                        encrypted="true"
                        shift
                        ;;
                    --no-index)
                        no_index="true"
                        shift
                        ;;
                    *)
                        print_error "Unknown option: $1"
                        echo "Usage: ramdisk create <size_mb> <name> [--encrypted] [--no-index]"
                        exit 1
                        ;;
                esac
            done

            create_ramdisk "$size_mb" "$volume_name" "$encrypted" "$no_index"
            ;;

        list)
            list_ramdisks
            ;;

        destroy)
            if [[ $# -ne 1 ]]; then
                print_error "Invalid arguments for 'destroy' command"
                echo "Usage: ramdisk destroy <volume_name_or_device>"
                exit 1
            fi
            destroy_ramdisk "$1"
            ;;

        help|--help|-h)
            show_usage
            ;;

        version|--version|-v)
            echo "ramdisk version ${VERSION}"
            ;;

        *)
            print_error "Unknown command: $command"
            echo ""
            show_usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
